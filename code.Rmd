---
title: "predict the goose"
output: github_document
---

```{r setup, include=FALSE}
library(tidyverse)
library(fpp2)
library(lubridate)
library(timeDate)
source("stathol.R")
knitr::opts_chunk$set(echo = FALSE)
```

```{r getdata, echo=FALSE, message = FALSE,warning = FALSE}
goose <- read_csv("data.csv")
goose$date <- parse_date(goose$date, "%m/%d/%Y")
goose$day=as.factor(weekdays(goose$date))
tsstart <- c(year(goose$date[1]),as.numeric(format(goose$date[1], "%j")))
gmts <- msts(goose$cyclists,seasonal.periods=c(7,365.25),start=tsstart)
gts <- ts(goose$cyclists, frequency=365.25, start=tsstart)
trainms <- subset(gmts, end=length(gmts)-14)
testms <- subset(gmts, start=length(gmts)-13)
train <- subset(gts, end=length(gts)-14)
test <- subset(gts, start=length(gts)-13)
```

## Plot the whole series and just 2018


```{r goose, echo=FALSE, message = FALSE, warning = FALSE}
p1 <- autoplot(gmts)+ylab("cyclists") + xlab("Years")+ggtitle("Goose: All Data")
p2 <- ggplot(filter(goose,year(date)=="2018"), aes(date, cyclists)) + xlab("Weeks")+ggtitle("Goose: 2018")+
  geom_line()+scale_x_date(date_breaks = "4 weeks", date_labels = "%W",date_minor_breaks = "1 week")

gridExtra::grid.arrange(p1,p2)
```

## SLT Decomposition

Of the whole series, assuming weekly and yearly seasonality.


```{r stl, echo=FALSE}
gmts %>% mstl() %>% 
  autoplot() 
```

## forecast based on stlf

```{r goose-stlf, echo=FALSE}
stlfor <- trainms %>%  stlf(h=14) 
stlfor %>% autoplot(include=5*7) + xlab("Week")
accuracy(stlfor, testms)
stlfor %>% checkresiduals()
```

## Forecast based on Dynamic harmonic regression

```{r chooseKs, echo=FALSE}
# rmse <- list()
# for (i in seq(3)){
#   for (j in seq(10)){
#   fit <- auto.arima(trainms, xreg = fourier(trainms, K = c(i,j)),
#     seasonal = FALSE, lambda = 0)
#   forfit <- forecast(fit,xreg=fourier(trainms, K=c(i,j), h=14))
#   rmse[[paste(i,j,sep=".")]] <-accuracy(forfit, testms)["Test set","RMSE"]
#   } 
# }
# rmse[which(min(unlist(rmse))==rmse)]
```

```{r fourier, echo=FALSE}
ks <- c(2,2)
fourmod <- auto.arima(trainms, seasonal=FALSE,xreg=fourier(trainms, K=ks),lambda = 0)
fourfor <- fourmod %>% forecast(xreg=fourier(trainms, K=ks, h=14))
fourfor %>% autoplot(include=35) + ylab("cyclists") + xlab("Weeks")
accuracy(fourfor, testms)
fourfor %>% checkresiduals()
```

## forecast based on TBATS

```{r goose-tbats, echo=FALSE}
tbatsfit <- trainms %>%  tbats() 
tbatsfor <- forecast(tbatsfit,h=14)
tbatsfor %>% autoplot(include=5*7) + xlab("Week")
accuracy(tbatsfor, testms)
tbatsfor %>% checkresiduals()
```

## Deal with stat holidays
```{r holi, echo=FALSE}
#tsstartw <- c(year(goose$date[1]), as.numeric(format(goose$date[1], "%j")))
y <- ts(goose$cyclists, frequency=7) 
y <- subset(y, end=length(y)-14)
z <- fourier(train, K=6)
zf <- fourier(train, K=6, h=14)
holiday <- select(stat.hol(goose$date[1],tail(goose$date,n=1)-days(14)),-date)
holidayf <- select(stat.hol(tail(goose$date,n=1)-days(13),tail(goose$date,n=1)),-date)
xr <- cbind(z,holiday)
fit <- auto.arima(y, xreg=xr, seasonal=FALSE)
fc <- forecast(fit, xreg=cbind(zf,holidayf), h=14)
fc %>% autoplot(include=5*7) + xlab("Week")
accuracy(unclass(fc$mean), unclass(test))
fc %>% checkresiduals()

```






## Combine the forecasts

```{r combine, echo=FALSE}
combf <- (fourfor$mean+stlfor$mean+tbatsfor$mean+unclass(fc$mean))/4
accuracy(combf,testms)
```

```{r plots, echo=FALSE}
  autoplot(tail(gmts,n=49)) +
  autolayer(stlfor, series="STL", PI=FALSE) +
  autolayer(fourfor, series="Fourier", PI=FALSE) +
  autolayer(tbatsfor, series="TBATS", PI=FALSE) +
 # autolayer(fc$mean, series="holi", PI=FALSE) +
  autolayer(combf, series="Combined") +
  xlab("Year") + ylab("cyclists") +
  ggtitle("Goose")
```
